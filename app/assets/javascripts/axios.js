var axios =
/******/ (function(modules) { // webpackBootstrap
/******/  // The module cache
/******/  var installedModules = {};
/******/
/******/  // The require function
/******/  function __webpack_require__(moduleId) {
/******/
/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;
/******/
/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      exports: {},
/******/      id: moduleId,
/******/      loaded: false
/******/    };
/******/
/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/    // Flag the module as loaded
/******/    module.loaded = true;
/******/
/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }
/******/
/******/
/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;
/******/
/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;
/******/
/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "";
/******/
/******/  // Load entry module and return exports
/******/  return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

  module.exports = __webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(process) {var Promise = __webpack_require__(13).Promise;
  var defaults = __webpack_require__(3);
  var utils = __webpack_require__(4);

  var axios = module.exports = function axios(config) {
    config = utils.merge({
      method: 'get',
      headers: {},
      transformRequest: defaults.transformRequest,
      transformResponse: defaults.transformResponse
    }, config);

    // Don't allow overriding defaults.withCredentials
    config.withCredentials = config.withCredentials || defaults.withCredentials;

    var promise = new Promise(function (resolve, reject) {
      try {
        // For browsers use XHR adapter
        if (typeof window !== 'undefined') {
          __webpack_require__(5)(resolve, reject, config);
        }
        // For node use HTTP adapter
        else if (typeof process !== 'undefined') {
          __webpack_require__(2)(resolve, reject, config);
        }
      } catch (e) {
        reject(e);
      }
    });

    function deprecatedMethod(method, instead, docs) {
      try {
        console.warn(
          'DEPRECATED method `' + method + '`.' +
          (instead ? ' Use `' + instead + '` instead.' : '') +
          ' This method will be removed in a future release.');

        if (docs) {
          console.warn('For more information about usage see ' + docs);
        }
      } catch (e) {}
    }

    // Provide alias for success
    promise.success = function success(fn) {
      deprecatedMethod('success', 'then', 'https://github.com/mzabriskie/axios/blob/master/README.md#response-api');

      promise.then(function(response) {
        fn(response.data, response.status, response.headers, response.config);
      });
      return promise;
    };

    // Provide alias for error
    promise.error = function error(fn) {
      deprecatedMethod('error', 'catch', 'https://github.com/mzabriskie/axios/blob/master/README.md#response-api');

      promise.then(null, function(response) {
        fn(response.data, response.status, response.headers, response.config);
      });
      return promise;
    };

    return promise;
  };

  // Expose defaults
  axios.defaults = defaults;

  // Expose all/spread
  axios.all = function (promises) {
    return Promise.all(promises);
  };
  axios.spread = __webpack_require__(6);

  // Provide aliases for supported request methods
  createShortMethods('delete', 'get', 'head');
  createShortMethodsWithData('post', 'put', 'patch');

  function createShortMethods() {
    utils.forEach(arguments, function (method) {
      axios[method] = function (url, config) {
        return axios(utils.merge(config || {}, {
          method: method,
          url: url
        }));
      };
    });
  }

  function createShortMethodsWithData() {
    utils.forEach(arguments, function (method) {
      axios[method] = function (url, data, config) {
        return axios(utils.merge(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });
  }
  /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

  if(typeof undefined === 'undefined') {var e = new Error("Cannot find module \"undefined\""); e.code = 'MODULE_NOT_FOUND'; throw e;}
  module.exports = undefined;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var utils = __webpack_require__(4);

  var JSON_START = /^\s*(\[|\{[^\{])/;
  var JSON_END = /[\}\]]\s*$/;
  var PROTECTION_PREFIX = /^\)\]\}',?\n/;
  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  module.exports = {
    transformRequest: [function (data, headers) {
      if (utils.isArrayBuffer(data)) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isObject(data) && !utils.isFile(data) && !utils.isBlob(data)) {
        // Set application/json if no Content-Type has been specified
        if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
          headers['Content-Type'] = 'application/json;charset=utf-8';
        }
        return JSON.stringify(data);
      }
      return data;
    }],

    transformResponse: [function (data) {
      if (typeof data === 'string') {
        data = data.replace(PROTECTION_PREFIX, '');
        if (JSON_START.test(data) && JSON_END.test(data)) {
          data = JSON.parse(data);
        }
      }
      return data;
    }],

    headers: {
      common: {
        'Accept': 'application/json, text/plain, */*'
      },
      patch: utils.merge(DEFAULT_CONTENT_TYPE),
      post: utils.merge(DEFAULT_CONTENT_TYPE),
      put: utils.merge(DEFAULT_CONTENT_TYPE)
    },

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN'
  };

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

  // utils is a library of generic helper functions non-specific to axios

  var toString = Object.prototype.toString;

  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */
  function isArray(val) {
    return toString.call(val) === '[object Array]';
  }

  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
  function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
  }

  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val) {
    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
      return ArrayBuffer.isView(val);
    } else {
      return (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
    }
  }

  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */
  function isString(val) {
    return typeof val === 'string';
  }

  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */
  function isNumber(val) {
    return typeof val === 'number';
  }

  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */
  function isUndefined(val) {
    return typeof val === 'undefined';
  }

  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */
  function isObject(val) {
    return val !== null && typeof val === 'object';
  }

  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */
  function isDate(val) {
    return toString.call(val) === '[object Date]';
  }

  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */
  function isFile(val) {
    return toString.call(val) === '[object File]';
  }

  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */
  function isBlob(val) {
    return toString.call(val) === '[object Blob]';
  }

  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */
  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }

  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array or arguments callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */
  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    }

    // Check if obj is array-like
    var isArray = obj.constructor === Array || typeof obj.callee === 'function';

    // Force an array if not already something iterable
    if (typeof obj !== 'object' && !isArray) {
      obj = [obj];
    }

    // Iterate over array values
    if (isArray) {
      for (var i=0, l=obj.length; i<l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    }
    // Iterate over object keys
    else {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }

  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function merge(obj1/*, obj2, obj3, ...*/) {
    var result = {};
    forEach(arguments, function (obj) {
      forEach(obj, function (val, key) {
        result[key] = val;
      });
    });
    return result;
  }

  module.exports = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    forEach: forEach,
    merge: merge,
    trim: trim
  };

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

  var defaults = __webpack_require__(3);
  var utils = __webpack_require__(4);
  var buildUrl = __webpack_require__(8);
  var cookies = __webpack_require__(9);
  var parseHeaders = __webpack_require__(10);
  var transformData = __webpack_require__(11);
  var urlIsSameOrigin = __webpack_require__(12);

  module.exports = function xhrAdapter(resolve, reject, config) {
    // Transform request data
    var data = transformData(
      config.data,
      config.headers,
      config.transformRequest
    );

    // Merge headers
    var headers = utils.merge(
      defaults.headers.common,
      defaults.headers[config.method] || {},
      config.headers || {}
    );

    // Create the request
    var request = new(XMLHttpRequest || ActiveXObject)('Microsoft.XMLHTTP');
    request.open(config.method, buildUrl(config.url, config.params), true);

    // Listen for ready state
    request.onreadystatechange = function () {
      if (request && request.readyState === 4) {
        // Prepare the response
        var headers = parseHeaders(request.getAllResponseHeaders());
        var response = {
          data: transformData(
            request.responseText,
            headers,
            config.transformResponse
          ),
          status: request.status,
          headers: headers,
          config: config
        };

        // Resolve or reject the Promise based on the status
        (request.status >= 200 && request.status < 300
          ? resolve
          : reject)(response);

        // Clean up request
        request = null;
      }
    };

    // Add xsrf header
    var xsrfValue = urlIsSameOrigin(config.url)
      ? cookies.read(config.xsrfCookieName || defaults.xsrfCookieName)
      : undefined;
    if (xsrfValue) {
      headers[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
    }

    // Add headers to the request
    utils.forEach(headers, function (val, key) {
      // Remove Content-Type if data is undefined
      if (!data && key.toLowerCase() === 'content-type') {
        delete headers[key];
      }
      // Otherwise add header to the request
      else {
        request.setRequestHeader(key, val);
      }
    });

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        if (request.responseType !== 'json') {
          throw e;
        }
      }
    }

    if (utils.isArrayBuffer(data)) {
      data = new DataView(data);
    }

    // Send the request
    request.send(data);
  };

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */
  module.exports = function spread(callback) {
    return function (arr) {
      callback.apply(null, arr);
    };
  };

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

  // shim for using process in browser

  var process = module.exports = {};

  process.nextTick = (function () {
      var canSetImmediate = typeof window !== 'undefined'
      && window.setImmediate;
      var canPost = typeof window !== 'undefined'
      && window.postMessage && window.addEventListener
      ;

      if (canSetImmediate) {
          return function (f) { return window.setImmediate(f) };
      }

      if (canPost) {
          var queue = [];
          window.addEventListener('message', function (ev) {
              var source = ev.source;
              if ((source === window || source === null) && ev.data === 'process-tick') {
                  ev.stopPropagation();
                  if (queue.length > 0) {
                      var fn = queue.shift();
                      fn();
                  }
              }
          }, true);

          return function nextTick(fn) {
              queue.push(fn);
              window.postMessage('process-tick', '*');
          };
      }

      return function nextTick(fn) {
          setTimeout(fn, 0);
      };
  })();

  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];

  function noop() {}

  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;

  process.binding = function (name) {
      throw new Error('process.binding is not supported');
  }

  // TODO(shtylman)
  process.cwd = function () { return '/' };
  process.chdir = function (dir) {
      throw new Error('process.chdir is not supported');
  };


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var utils = __webpack_require__(4);

  function encode(val) {
    return encodeURIComponent(val).
      replace(/%40/gi, '@').
      replace(/%3A/gi, ':').
      replace(/%24/g, '$').
      replace(/%2C/gi, ',').
      replace(/%20/g, '+');
  }

  module.exports = function buildUrl(url, params) {
    if (!params) {
      return url;
    }

    var parts = [];

    utils.forEach(params, function (val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }
      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function (v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        }
        else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    if (parts.length > 0) {
      url += (url.indexOf('?') === -1 ? '?' : '&') + parts.join('&');
    }

    return url;
  };

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var utils = __webpack_require__(4);

  module.exports = {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var utils = __webpack_require__(4);

  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */
  module.exports = function parseHeaders(headers) {
    var parsed = {}, key, val, i;

    if (!headers) return parsed;

    utils.forEach(headers.split('\n'), function(line) {
      i = line.indexOf(':');
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));

      if (key) {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    });

    return parsed;
  };

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var utils = __webpack_require__(4);

  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */
  module.exports = function transformData(data, headers, fns) {
    utils.forEach(fns, function (fn) {
      data = fn(data, headers);
    });

    return data;
  };

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

  'use strict';

  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var utils = __webpack_require__(4);
  var urlParsingNode = document.createElement('a');
  var originUrl = urlResolve(window.location.href);

  /**
   * Parse a URL to discover it's components
   *
   * @param {String} url The URL to be parsed
   * @returns {Object}
   */
  function urlResolve(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: (urlParsingNode.pathname.charAt(0) === '/')
        ? urlParsingNode.pathname
        : '/' + urlParsingNode.pathname
    };
  }

  /**
   * Determine if a URL shares the same origin as the current location
   *
   * @param {String} requestUrl The URL to test
   * @returns {boolean} True if URL shares the same origin, otherwise false
   */
  module.exports = function urlIsSameOrigin(requestUrl) {
    var parsed = (utils.isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
    return (parsed.protocol === originUrl.protocol &&
          parsed.host === originUrl.host);
  };

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";
  var Promise = __webpack_require__(14).Promise;
  var polyfill = __webpack_require__(15).polyfill;
  exports.Promise = Promise;
  exports.polyfill = polyfill;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";
  var config = __webpack_require__(16).config;
  var configure = __webpack_require__(16).configure;
  var objectOrFunction = __webpack_require__(17).objectOrFunction;
  var isFunction = __webpack_require__(17).isFunction;
  var now = __webpack_require__(17).now;
  var all = __webpack_require__(18).all;
  var race = __webpack_require__(19).race;
  var staticResolve = __webpack_require__(20).resolve;
  var staticReject = __webpack_require__(21).reject;
  var asap = __webpack_require__(22).asap;

  var counter = 0;

  config.async = asap; // default async is asap;

  function Promise(resolver) {
    if (!isFunction(resolver)) {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    if (!(this instanceof Promise)) {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    this._subscribers = [];

    invokeResolver(resolver, this);
  }

  function invokeResolver(resolver, promise) {
    function resolvePromise(value) {
      resolve(promise, value);
    }

    function rejectPromise(reason) {
      reject(promise, reason);
    }

    try {
      resolver(resolvePromise, rejectPromise);
    } catch(e) {
      rejectPromise(e);
    }
  }

  function invokeCallback(settled, promise, callback, detail) {
    var hasCallback = isFunction(callback),
        value, error, succeeded, failed;

    if (hasCallback) {
      try {
        value = callback(detail);
        succeeded = true;
      } catch(e) {
        failed = true;
        error = e;
      }
    } else {
      value = detail;
      succeeded = true;
    }

    if (handleThenable(promise, value)) {
      return;
    } else if (hasCallback && succeeded) {
      resolve(promise, value);
    } else if (failed) {
      reject(promise, error);
    } else if (settled === FULFILLED) {
      resolve(promise, value);
    } else if (settled === REJECTED) {
      reject(promise, value);
    }
  }

  var PENDING   = void 0;
  var SEALED    = 0;
  var FULFILLED = 1;
  var REJECTED  = 2;

  function subscribe(parent, child, onFulfillment, onRejection) {
    var subscribers = parent._subscribers;
    var length = subscribers.length;

    subscribers[length] = child;
    subscribers[length + FULFILLED] = onFulfillment;
    subscribers[length + REJECTED]  = onRejection;
  }

  function publish(promise, settled) {
    var child, callback, subscribers = promise._subscribers, detail = promise._detail;

    for (var i = 0; i < subscribers.length; i += 3) {
      child = subscribers[i];
      callback = subscribers[i + settled];

      invokeCallback(settled, child, callback, detail);
    }

    promise._subscribers = null;
  }

  Promise.prototype = {
    constructor: Promise,

    _state: undefined,
    _detail: undefined,
    _subscribers: undefined,

    then: function(onFulfillment, onRejection) {
      var promise = this;

      var thenPromise = new this.constructor(function() {});

      if (this._state) {
        var callbacks = arguments;
        config.async(function invokePromiseCallback() {
          invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
        });
      } else {
        subscribe(this, thenPromise, onFulfillment, onRejection);
      }

      return thenPromise;
    },

    'catch': function(onRejection) {
      return this.then(null, onRejection);
    }
  };

  Promise.all = all;
  Promise.race = race;
  Promise.resolve = staticResolve;
  Promise.reject = staticReject;

  function handleThenable(promise, value) {
    var then = null,
    resolved;

    try {
      if (promise === value) {
        throw new TypeError("A promises callback cannot return that same promise.");
      }

      if (objectOrFunction(value)) {
        then = value.then;

        if (isFunction(then)) {
          then.call(value, function(val) {
            if (resolved) { return true; }
            resolved = true;

            if (value !== val) {
              resolve(promise, val);
            } else {
              fulfill(promise, val);
            }
          }, function(val) {
            if (resolved) { return true; }
            resolved = true;

            reject(promise, val);
          });

          return true;
        }
      }
    } catch (error) {
      if (resolved) { return true; }
      reject(promise, error);
      return true;
    }

    return false;
  }

  function resolve(promise, value) {
    if (promise === value) {
      fulfill(promise, value);
    } else if (!handleThenable(promise, value)) {
      fulfill(promise, value);
    }
  }

  function fulfill(promise, value) {
    if (promise._state !== PENDING) { return; }
    promise._state = SEALED;
    promise._detail = value;

    config.async(publishFulfillment, promise);
  }

  function reject(promise, reason) {
    if (promise._state !== PENDING) { return; }
    promise._state = SEALED;
    promise._detail = reason;

    config.async(publishRejection, promise);
  }

  function publishFulfillment(promise) {
    publish(promise, promise._state = FULFILLED);
  }

  function publishRejection(promise) {
    publish(promise, promise._state = REJECTED);
  }

  exports.Promise = Promise;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(global) {"use strict";
  /*global self*/
  var RSVPPromise = __webpack_require__(14).Promise;
  var isFunction = __webpack_require__(17).isFunction;

  function polyfill() {
    var local;

    if (typeof global !== 'undefined') {
      local = global;
    } else if (typeof window !== 'undefined' && window.document) {
      local = window;
    } else {
      local = self;
    }

    var es6PromiseSupport =
      "Promise" in local &&
      // Some of these methods are missing from
      // Firefox/Chrome experimental implementations
      "resolve" in local.Promise &&
      "reject" in local.Promise &&
      "all" in local.Promise &&
      "race" in local.Promise &&
      // Older version of the spec had a resolver object
      // as the arg rather than a function
      (function() {
        var resolve;
        new local.Promise(function(r) { resolve = r; });
        return isFunction(resolve);
      }());

    if (!es6PromiseSupport) {
      local.Promise = RSVPPromise;
    }
  }

  exports.polyfill = polyfill;
  /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";
  var config = {
    instrument: false
  };

  function configure(name, value) {
    if (arguments.length === 2) {
      config[name] = value;
    } else {
      return config[name];
    }
  }

  exports.config = config;
  exports.configure = configure;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";
  function objectOrFunction(x) {
    return isFunction(x) || (typeof x === "object" && x !== null);
  }

  function isFunction(x) {
    return typeof x === "function";
  }

  function isArray(x) {
    return Object.prototype.toString.call(x) === "[object Array]";
  }

  // Date.now is not available in browsers < IE9
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
  var now = Date.now || function() { return new Date().getTime(); };


  exports.objectOrFunction = objectOrFunction;
  exports.isFunction = isFunction;
  exports.isArray = isArray;
  exports.now = now;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";
  /* global toString */

  var isArray = __webpack_require__(17).isArray;
  var isFunction = __webpack_require__(17).isFunction;

  /**
    Returns a promise that is fulfilled when all the given promises have been
    fulfilled, or rejected if any of them become rejected. The return promise
    is fulfilled with an array that gives all the values in the order they were
    passed in the `promises` array argument.

    Example:

    ```javascript
    var promise1 = RSVP.resolve(1);
    var promise2 = RSVP.resolve(2);
    var promise3 = RSVP.resolve(3);
    var promises = [ promise1, promise2, promise3 ];

    RSVP.all(promises).then(function(array){
      // The array here would be [ 1, 2, 3 ];
    });
    ```

    If any of the `promises` given to `RSVP.all` are rejected, the first promise
    that is rejected will be given as an argument to the returned promises's
    rejection handler. For example:

    Example:

    ```javascript
    var promise1 = RSVP.resolve(1);
    var promise2 = RSVP.reject(new Error("2"));
    var promise3 = RSVP.reject(new Error("3"));
    var promises = [ promise1, promise2, promise3 ];

    RSVP.all(promises).then(function(array){
      // Code here never runs because there are rejected promises!
    }, function(error) {
      // error.message === "2"
    });
    ```

    @method all
    @for RSVP
    @param {Array} promises
    @param {String} label
    @return {Promise} promise that is fulfilled when all `promises` have been
    fulfilled, or rejected if any of them become rejected.
  */
  function all(promises) {
    /*jshint validthis:true */
    var Promise = this;

    if (!isArray(promises)) {
      throw new TypeError('You must pass an array to all.');
    }

    return new Promise(function(resolve, reject) {
      var results = [], remaining = promises.length,
      promise;

      if (remaining === 0) {
        resolve([]);
      }

      function resolver(index) {
        return function(value) {
          resolveAll(index, value);
        };
      }

      function resolveAll(index, value) {
        results[index] = value;
        if (--remaining === 0) {
          resolve(results);
        }
      }

      for (var i = 0; i < promises.length; i++) {
        promise = promises[i];

        if (promise && isFunction(promise.then)) {
          promise.then(resolver(i), reject);
        } else {
          resolveAll(i, promise);
        }
      }
    });
  }

  exports.all = all;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";
  /* global toString */
  var isArray = __webpack_require__(17).isArray;

  /**
    `RSVP.race` allows you to watch a series of promises and act as soon as the
    first promise given to the `promises` argument fulfills or rejects.

    Example:

    ```javascript
    var promise1 = new RSVP.Promise(function(resolve, reject){
      setTimeout(function(){
        resolve("promise 1");
      }, 200);
    });

    var promise2 = new RSVP.Promise(function(resolve, reject){
      setTimeout(function(){
        resolve("promise 2");
      }, 100);
    });

    RSVP.race([promise1, promise2]).then(function(result){
      // result === "promise 2" because it was resolved before promise1
      // was resolved.
    });
    ```

    `RSVP.race` is deterministic in that only the state of the first completed
    promise matters. For example, even if other promises given to the `promises`
    array argument are resolved, but the first completed promise has become
    rejected before the other promises became fulfilled, the returned promise
    will become rejected:

    ```javascript
    var promise1 = new RSVP.Promise(function(resolve, reject){
      setTimeout(function(){
        resolve("promise 1");
      }, 200);
    });

    var promise2 = new RSVP.Promise(function(resolve, reject){
      setTimeout(function(){
        reject(new Error("promise 2"));
      }, 100);
    });

    RSVP.race([promise1, promise2]).then(function(result){
      // Code here never runs because there are rejected promises!
    }, function(reason){
      // reason.message === "promise2" because promise 2 became rejected before
      // promise 1 became fulfilled
    });
    ```

    @method race
    @for RSVP
    @param {Array} promises array of promises to observe
    @param {String} label optional string for describing the promise returned.
    Useful for tooling.
    @return {Promise} a promise that becomes fulfilled with the value the first
    completed promises is resolved with if the first completed promise was
    fulfilled, or rejected with the reason that the first completed promise
    was rejected with.
  */
  function race(promises) {
    /*jshint validthis:true */
    var Promise = this;

    if (!isArray(promises)) {
      throw new TypeError('You must pass an array to race.');
    }
    return new Promise(function(resolve, reject) {
      var results = [], promise;

      for (var i = 0; i < promises.length; i++) {
        promise = promises[i];

        if (promise && typeof promise.then === 'function') {
          promise.then(resolve, reject);
        } else {
          resolve(promise);
        }
      }
    });
  }

  exports.race = race;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";
  function resolve(value) {
    /*jshint validthis:true */
    if (value && typeof value === 'object' && value.constructor === this) {
      return value;
    }

    var Promise = this;

    return new Promise(function(resolve) {
      resolve(value);
    });
  }

  exports.resolve = resolve;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

  "use strict";
  /**
    `RSVP.reject` returns a promise that will become rejected with the passed
    `reason`. `RSVP.reject` is essentially shorthand for the following:

    ```javascript
    var promise = new RSVP.Promise(function(resolve, reject){
      reject(new Error('WHOOPS'));
    });

    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```

    Instead of writing the above, your code now simply becomes the following:

    ```javascript
    var promise = RSVP.reject(new Error('WHOOPS'));

    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```

    @method reject
    @for RSVP
    @param {Any} reason value that the returned promise will be rejected with.
    @param {String} label optional string for identifying the returned promise.
    Useful for tooling.
    @return {Promise} a promise that will become rejected with the given
    `reason`.
  */
  function reject(reason) {
    /*jshint validthis:true */
    var Promise = this;

    return new Promise(function (resolve, reject) {
      reject(reason);
    });
  }

  exports.reject = reject;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

  /* WEBPACK VAR INJECTION */(function(global, process) {"use strict";
  var browserGlobal = (typeof window !== 'undefined') ? window : {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);

  // node
  function useNextTick() {
    return function() {
      process.nextTick(flush);
    };
  }

  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, { characterData: true });

    return function() {
      node.data = (iterations = ++iterations % 2);
    };
  }

  function useSetTimeout() {
    return function() {
      local.setTimeout(flush, 1);
    };
  }

  var queue = [];
  function flush() {
    for (var i = 0; i < queue.length; i++) {
      var tuple = queue[i];
      var callback = tuple[0], arg = tuple[1];
      callback(arg);
    }
    queue = [];
  }

  var scheduleFlush;

  // Decide what async method to use to triggering processing of queued callbacks:
  if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else {
    scheduleFlush = useSetTimeout();
  }

  function asap(callback, arg) {
    var length = queue.push([callback, arg]);
    if (length === 1) {
      // If length is 1, that means that we need to schedule an async flush.
      // If additional callbacks are queued before the queue is flushed, they
      // will be processed by this flush that we are scheduling.
      scheduleFlush();
    }
  }

  exports.asap = asap;
  /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(7)))

/***/ }
/******/ ])
//# sourceMappingURL=axios.map
